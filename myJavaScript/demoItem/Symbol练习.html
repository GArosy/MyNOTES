<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symbol 练习</title>
    <style>
        * {
            margin: auto;
            padding: 0;
            text-align: center;
        }
    </style>
</head>

<body>
    <h1>Symbol 练习</h1>
    <div></div>
    <script>
        // 1.声明symbol的方式
        // //  1）直接定义
        // let sym = Symbol('your description');
        // console.log(sym);   // Symbol(your description)
        // console.log(sym.description);   // your description
        // //  2）Symbol.for()定义
        // let sym1 = Symbol('描述一');
        // let sym2 = Symbol('描述一');
        // let symFor1 = Symbol.for('描述一');
        // let symFor2 = Symbol.for('描述一');
        // console.log(sym1 == sym2);    // false，直接定义的Symbol具有绝对唯一性，不随描述更改
        // console.log(symFor1 == sym1);   // false，直接定义的Symbol和for定义的相互独立
        // console.log(symFor1 == symFor2);    // true，for根据描述获取Symbol，如果不存在则新建一个Symbol

        // 2.symbol解决字符串耦合问题
        // //  eg：
        // let user1 = 'Tom';
        // let user2 = 'Tom';
        // let grade = {
        //     [user1] : { js: 100, css: 95 },
        //     [user2] : { js: 60, css: 55 }
        // }
        // console.log(grade);// Tom: {css: 55, js: 60} 对象发生覆盖！
        // //  解决1：
        // let user1 = {
        //     name: 'Tom',
        //     key: Symbol()
        // };
        // let user2 = {
        //     name: 'Tom',
        //     key: Symbol()
        // };
        // let grade = {
        //     [user1.key]: { js: 100, css: 95 },
        //     [user2.key]: { js: 60, css: 55 }
        // }
        // console.log(grade[user1.key]);// {js: 100, css: 95}

        // 3.扩展特性与属性保护
        // let age = Symbol("");
        // let obj = {
        //     name: "Tom",
        //     [age]: 23
        // }
        // for (const key in obj) {
        //     console.log(key);
        // }   // name
        // for (const key of Object.keys(obj)) {
        //     console.log(key);
        // }   // name
        // // 普通遍历方法无法获取[age]，Symbol起到了保护属性的作用
        // for (const key of Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj))) {
        //     console.log(key);
        // }   // name Symbol() ，Object分别获取对象内的普通属性和Symbol
        // for (const key of Reflect.ownKeys(obj)) {
        //     console.log(key);
        // }   // name Symbol() ，Reflect是一个内置对象，等同于以上方法
    </script>
</body>

</html>