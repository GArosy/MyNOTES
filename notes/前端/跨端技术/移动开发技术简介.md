## 1. 原生开发

#### 概念

原生应用程序指某一移动平台（比如iOS或安卓）的特有应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。

Android原生应用：使用Java/Kotlin语言，直接调用Android SDK开发的应用程序。

iOS原生应用：使用Objective-C/Swift语言，直接调用iOS SDK开发。

#### 优缺点

- 可访问平台全部功能（GPS、摄像头）
- 速度快、性能高、可以实现复杂动画及绘制，整体用户体验好
- 平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大；
- 内容固定，动态化弱，大多数情况下，有新功能更新时只能发版

#### 局限性

随着物联网时代到来，移动互联网高歌猛进，传统的纯原生开发已经不能满足日益增长的业务需求。主要局限在：

- 动态化内容需求增大；当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这对高速变化的互联网时代来说是很难接受的，对应用动态化(不发版也可以更新应用内容)的需求就变的迫在眉睫。
- 业务需求变化快，开发成本变大；由于原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，无论人力成本，还是测试成本都会变大。

总结一下，纯原生开发主要面临==动态化==和==开发成本==两个问题，而针对这两个问题，诞生了一些跨平台的动态化框架。

## 2. 跨平台技术

针对原生开发面临的问题，业界一直都在努力寻找好的解决方案。时至今日已经有很多跨平台框架，根据其原理主要分为三类：

- H5 + WebView（Cordova、Ionic、微信小程序）
- JS + 原生渲染（React Native、Weex）
- 自绘UI + 原生（Qt for mobile、Flutter）

#### 混合开发

通过平台原生的WebView控件（原生内置的浏览器内核）加载HTML5。

这种方案中，H5 部分可随时变更而不用发版，动态化需求能满足；同时，由于 H5 代码只需一次开发就能同时在 Android 和 iOS 两个平台运行，可以减小开发成本（H5 部分功能越多，开发成本就越小）。我们称这种 H5 + 原生 的开发模式为**混合开发（Hybrid）** ，采用混合模式开发的App我们称之为**混合应用**或 **HTMLybrid App** ，如果一个应用的大多数功能都是 H5 实现的话，我们称其为 **Web App** 。

混合开发框架的典型代表有：Cordova、Ionic

优点：动态内容可以用 H5开发，而H5是Web 技术栈，Web技术栈生态开放且社区资源丰富，整体开发效率高。

缺点：性能体验不佳，对于复杂用户界面或动画，WebView 有时会不堪重任。

目前为止，HTMLybrid App 仍然是最通用且最成熟的跨端解决方案。国内各家公司小程序应用层的开发技术栈是 Web 技术栈，而底层渲染方式基本都是 WebView 和原生相结合的方式。

#### JS+原生渲染

以web开发为例，React、Vue等框架通过JS维护虚拟DOM的方式更新浏览器DOM，以达到由数据驱动UI的目的。

Facebook团队将React的设计扩展到移动应用平台，**React Native** 由此诞生。它通过JavaScriptCore引擎，将虚拟DOM映射为原生控件树，原生应用根据收到的虚拟DOM布局信息，将对应的原生控件渲染，以此实现了跨平台能力。

> JavaScriptCore为JS提供运行环境，搭建了JS与原生应用通信的桥梁。

相对于混合应用，由于React Native由原生控件实现渲染，所以性能会比混合应用中 H5 好一些，同时 React Native 提供了很多原生组件对应的 Web 组件，大多数情况下开发者只需要使用Web 技术栈就能开发出 App。

2016年，阿里巴巴发布了 **Weex** 框架，其原理与RN类似，底层都由原生渲染，区别在于应用层开发语法：Weex支持Vue和Rax语法。自此Vue和React在移动端开发上有了各自的一席之地。

优点：

1. 采用 Web 开发技术栈，社区庞大、上手快、开发成本相对较低。
2. 原生渲染，性能相比 H5 提高很多。
3. 动态化较好，支持热更新。

缺点：

1. **通信开销**：渲染时需要 JavaScript 和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。
2. **JS性能问题**：JavaScript 为脚本语言，执行时需要解释执行 （JIT， Just In Time），执行效率和编译类语言（AOT，Ahead Of Time）仍有差距。
3. **控件维护**：由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在 Android 中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。这就会导致，如果需要自定义原生渲染组件时，开发和维护成本过高。

#### 自绘UI+原生

技术思路：通过在不同平台实现一个**统一接口的渲染引擎**来绘制UI，而不依赖系统原生控件，所以可以做到不同平台UI的一致性。但是对于UI以外的系统能力调用，还需要原生支持。

优点：

1. 性能高：由于自绘引擎直接调用系统API来绘制UI，所以性能和原生控件接近。
2. 布局灵活：不依赖原生控件，也就不会受原生布局系统的限制。
3. 组件库易维护、UI外观保真度和一致性高：由于UI渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。由于组件库是同一套代码、同一个渲染引擎，所以在不同平台，组件显示外观可以做到高保真和高一致性。

缺点：

1. 动态性不足：为了保证UI绘制性能，自绘UI系统一般都会采用 AOT 模式编译其发布包，所以应用发布后，不能像 Hybrid 和 RN 使用 JavaScript（JIT）作为开发语言的框架那样动态下发代码。

第一个使用此设计的框架是Qt，它基于C++，但在种种原因下式微。

2017年，Google发布了Flutter，它放弃JS而转用Dart语言，同时支持JIT和snapshot的运行方式来实现动态化。比起Qt，Google在Flutter投入了大量资源，除了有着更活跃的社区生态，开发体验上也优于前者。

## 3. 总结

| 技术类型              | UI渲染方式      | 性能 | 开发效率        | 动态化     | 框架代表       |
| --------------------- | --------------- | ---- | --------------- | ---------- | -------------- |
| H5 + 原生             | WebView渲染     | 一般 | 高              | 支持       | Cordova、Ionic |
| JavaScript + 原生渲染 | 原生控件渲染    | 好   | 中              | 支持       | RN、Weex       |
| 自绘UI + 原生         | 调用系统API渲染 | 好   | Flutter高, Qt低 | 默认不支持 | Qt、Flutter    |

> 国内大厂的使用情况统计：https://segmentfault.com/a/1190000022961111
