# JS

## 1. 基本数据类型

- 7种值类型：Number、String，Boolean，Null、undefined，Symbol，BigInt；

- 1种引用类型：Object；

  js的变量存放于**堆**（对于有名对象， 会在栈中存一个**堆内地址的引用** （JS的栈与其他语言不同，属于抽象的执行上下文栈））

## 2. 闭包

常见说法：闭包是在某个作用域内定义的**函数和其词法环境的组合**，闭包让你可以在一个内层函数中访问到其外层函数的作用域。常使用于 **创建特权方法用于访问控制** 和 **回调函数** 中。

实际上，闭包其实是JavaScript内存使用机制产生的必然结果，它与**执行上下文**、**作用域与作用域对象**、**变量储存方式**、**垃圾回收机制**息息相关：

以chrome使用的V8引擎为例。如果我们在js中声明一个函数 `myFunc()`，myFunc标识符会在声明的同时存入当前的**作用域对象**中，这个标识符引用的是一个堆上的函数对象。而这个函数对象除了包含代码之外，还会产生一个内部属性 `[[scopes]]`，**scopes会反过来引用声明这个函数时所在的作用域对象的集合**，这个作用域对象就叫做 `myFunc()` 的**词法作用域**。由此可见，**凡是由我们主动声明的函数都会产生闭包**！（注意：这一切都发生在 `myFunc()` 执行之前）

当 `myFunc()` 执行开始时，JS的执行上下文栈会将 `myFunc()` 推到栈顶，同时产生一个新的作用域对象形成**作用域链**。当JS在当前作用域找不到变量时，就通过 `[[scopes]]` 去父作用域中寻找（这一点类似原型链），如果找到了，就会形成对**父作用域对象**的**引用**，当 `myFunc()` 执行结束出栈时，这个引用就会被解除。如果一个作用域对象不再被任何对象引用，就会被添加回收标记，在**垃圾回收器**（garbage collector）的下一次轮询中销毁。大部分函数的结果都是如此，它们产生的闭包转瞬即逝，不会被我们感知。

现在设想一种特殊情况：在全局中声明一个嵌套有子函数的函数，且子函数对父函数的属性**形成引用**。这时，如果我们将子函数作为父函数的返回值，这个返回值将作为全局变量保存起来，而**全局变量是不会被回收的**，那么意味着子函数的 `[[scopes]]` 保存的**父作用域对象也会一并保存下来**！即使父函数执行结束，它内部被引用的属性也不会销毁。这样一来，我们**能且只能**通过子函数随时访问这个父函数的变量，这个子函数即为**特权方法**，父函数的属性就是**私有属性**。

综上，闭包的优缺点也就呼之欲出：

- 优点： 保护函数内的变量安全 ，实现封装；在内存中维持一个变量，可以做缓存；
- 缺点： 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏；

>  [Javascript闭包：从理论到实现，[[Scopes\]]的每一根毛都看得清清楚楚](https://segmentfault.com/a/1190000015311755) 

## 3. let const

- 相同点：
  - 不存在变量提升，只能在定义后使用（出现**暂时性死区**）
  - 不能重复声明变量
  - 对 window 无影响，不会在window对象上添加全局对象的属性
- 不同点：
  - let声明变量，const声明常量
  - const声明时必须赋值
  - 如果const声明一个引用类型存放在**堆内存**，声明的**引用地址**不能改变，但**堆内存中的内容**可以改变
- var：有变量提升，只是改变了所声明变量的作用域，可以重复声明覆盖

# 模块化开发

## webpack





## CJS 与 ESM

`CommonJS`和`ESModule`都是JavaScript的**模块化方案**

### CJS

ConmmonJS主要用于服务器端，**只能在NodeJS上运行**，使用 `require('MODULE')` 读取并加载模块。

### ESM

ESModule是最新的模块方案，使用 `import` `export` 管理模块。

### 区别

- CJS**同步**加载模块，在执行时才会对模块建立对象的**拷贝**；

- ESM**提前**加载模块并编译，建立**静态引用**，所以import只能放在文件**开头**，不能放在条件语句内（而且不允许在外部直接修改模块的值）；基于这个差异，ESM在打包阶段更好做`tree-shaking`。



# 浏览器

## 1. 跨域

跨域问题产生的根源在于**浏览器需要遵循同源策略**，在它的限制下，前后端只有在**协议**、**域名**、**端口**都相同时才能交换数据。所以在**前后端分离**的项目中我们必须要**规避**这种限制。

### Proxy

我们前端在开发过程中解决跨域最常用的方法是在项目中**配置代理服务器**，利用了**服务器间通讯没有跨域问题**的机制，**使用代理服务器转发请求**，过程概括为：

1. 在`vue.config.js` 中配置`devServer.proxy`，添加一个**代理标识**对象，例如 `"api":{}` 。填入要代理的路径target，设置`changeOrigin`字段为true。如果请求url中含有代理标识，就触发代理机制， 发送的请求路径会被拼接为 target + 代理标识 + url ；
2. 在Axios中配置请求前缀baseURL为代理标识，这样使用axios发送请求会自动经过代理服务器；
3. 如果不想让代理标识出现在请求url中，可以在`pathRewrite`字段中将代理标识替换成空字符串。

使用devServer的问题是他仅适用于开发环境，当Vue项目打包成静态文件时，他的代理也就失灵了。在生产环境中，可以在**使用nginx的反向代理**达到同样的效果。

### CORS

现在在生产环境中使用的主流解决方案是 **CORS 跨域资源共享** ，它是一种**基于HTTP协议头**的机制，通过服务器在响应头**声明白名单**，使得浏览器允许白名单内的源访问加载自己的资源。

通常在服务器配置响应头 `Access-Control-Allow-Origin: *`  即可解决大部分解决前后端分离项目的跨域问题。

>  [一文弄懂 CORS 跨域(前端+后端代码实例讲解) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/118381660) 



## 2. Storage Cookie

- 相同点： 都会在**浏览器端**保存，有大小限制、同源限制；
- cookie：
  - 大小：4k
  - 通信：cookie会默认附在请求头中，**自动**发送到服务器，服务器可修改cookie；
  - 寿命：**会话期**cookie默认在**浏览器关闭**后移除；**持久性**cookie在**指定过期时间**删除
- Web Storage：
  - 大小：5M
  - 通信：web storage 不会发送到服务器；
  - 寿命：`sessionStorage` 在浏览器关闭时清空；`localStorage` 数据会保留至**主动**通过js清空或用户**清除浏览器缓存**；
  - 作用域：`sessionStorage` 必须在**同一窗口**下使用；`localStorage` 在**同源策略**下都可共享；

# VUE

## 1. vue2组件通信方式



## 2. 双向绑定



## 3. v-show v-if

- v-if在切换时会将条件块的事件监听器和子组件进行**销毁和重组**。如果初始条件为`false`，则什么也不做，直到条件为true时才会开始渲染。
- v-show只是**基于CSS**进行切换，不管初始条件如何，始终会渲染。

v-show的初始化开销更大，v-if的切换开销更大。

- 在需要频繁切换，或者切换部分DOM很复杂时，v-show更合适；
- 渲染后很少切换的，使用v-if更合适；

## 4. v-for中key的作用

`key`是给v-for中每个`vnode`指定的唯一id，在同级`vnode`diff过程中，可以通过`key`快速对比，来判断是否为相同节点，并且利用key的唯一性可以生成`map`来更快地获取相应节点。

# CSS

## BFC

**Block Formatting Context 块级格式化上下文** 

### 概念

BFC与IFC、FFC等概念同属于CSS**格式化上下文**的一种，实质是一种**布局环境**，它们规定了内部的box如何布局，从而形成了独立的渲染区域。

### 布局规则

- BFC内部的盒子从包含块的顶部，一个接着一个地放置**垂直排列**；
- BFC内部的盒子的**margin**紧贴包含块的**border**；
- 计算创建BFC的盒子高度时**会将浮动元素也计入其中**；

### 特性

通过为容器**创建BFC**可以使它成为**独立容器，与外界互不影响**：

- **包含内部浮动**，避免溢出导致浮动子元素令父元素高度坍塌；
- **排除外部浮动**，避免被覆盖；
- **避免外边距坍塌**，属于同一个BFC的相邻盒子垂直方向margin会重叠，将其放在不同的 BFC 容器中即可避免；

### 创建

创建BFC的方式有很多：

- 根元素
- 浮动元素（float不为none）
- 绝对定位元素（position为absolute或fixed）
- 表格元素
- 弹性元素、网格元素（display为flex/grid的直接子元素）
- `overflow` 不为visible的块元素

以上方法在某些情况下可能会产生**副作用**，如果要为一个容器专门创建BFC，建议使用的是 **`display: flow-root`** 属性，它可以创建无副作用的 BFC。

>  [块格式化上下文 - Web 开发者指南 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context) 
>
>  [视觉格式化模型 - CSS（层叠样式表） | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Visual_formatting_model) 
>
>  [Formatting context（FC） - 掘金 (juejin.cn)](https://juejin.cn/post/6974636270848835592) 
>
> block-level element =>  block-level box 块级元素生成块级盒子，如果**块级盒子**同时也是一个**块容器盒子 block container box **，则称其为**块盒子 block box **，