# JS

## 1. 基本数据类型

- 7种值类型：Number、String，Boolean，Null、undefined，Symbol，BigInt；

- 1种引用类型：Object；

  js的变量存放于**堆**（对于有名对象， 会在栈中存一个**堆内地址的引用** （JS的栈与其他语言不同，属于抽象的执行上下文栈））

## 2. 闭包

常见说法：闭包是在某个作用域内定义的**函数和其词法环境的组合**，闭包让你可以在一个内层函数中访问到其外层函数的作用域。常使用于 **创建特权方法用于访问控制** 和 **回调函数** 中。

实际上，闭包其实是JavaScript内存使用机制产生的必然结果，它与**执行上下文**、**作用域与作用域对象**、**变量储存方式**、**垃圾回收机制**息息相关：

以chrome使用的V8引擎为例。如果我们在js中声明一个函数 `myFunc()`，myFunc标识符会在声明的同时存入当前的**作用域对象**中，这个标识符引用的是一个堆上的函数对象。而这个函数对象除了包含代码之外，还会产生一个内部属性 `[[scopes]]`，**scopes会反过来引用声明这个函数时所在的作用域对象的集合**，这个作用域对象就叫做 `myFunc()` 的**词法作用域**。由此可见，**凡是由我们主动声明的函数都会产生闭包**！（注意：这一切都发生在 `myFunc()` 执行之前）

当 `myFunc()` 执行开始时，JS的执行上下文栈会将 `myFunc()` 推到栈顶，同时产生一个新的作用域对象形成**作用域链**。当JS在当前作用域找不到变量时，就通过 `[[scopes]]` 去父作用域中寻找（这一点类似原型链），如果找到了，就会形成对**父作用域对象**的**引用**，当 `myFunc()` 执行结束出栈时，这个引用就会被解除。如果一个作用域对象不再被任何对象引用，就会被添加回收标记，在**垃圾回收器**（garbage collector）的下一次轮询中销毁。大部分函数的结果都是如此，它们产生的闭包转瞬即逝，不会被我们感知。

现在设想一种特殊情况：在全局中声明一个嵌套有子函数的函数，且子函数对父函数的属性**形成引用**。这时，如果我们将子函数作为父函数的返回值，这个返回值将作为全局变量保存起来，而**全局变量是不会被回收的**，那么意味着子函数的 `[[scopes]]` 保存的**父作用域对象也会一并保存下来**！即使父函数执行结束，它内部被引用的属性也不会销毁。这样一来，我们**能且只能**通过子函数随时访问这个父函数的变量，这个子函数即为**特权方法**，父函数的属性就是**私有属性**。

综上，闭包的优缺点也就呼之欲出：

- 优点： 保护函数内的变量安全 ，实现封装；在内存中维持一个变量，可以做缓存；
- 缺点： 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏；

>  [Javascript闭包：从理论到实现，[[Scopes\]]的每一根毛都看得清清楚楚](https://segmentfault.com/a/1190000015311755) 

## 3. let const

- 相同点：
  - 不存在变量提升，只能在定义后使用（出现**暂时性死区**）
  - 不能重复声明变量
  - 对 window 无影响，不会在window对象上添加全局对象的属性
- 不同点：
  - let声明变量，const声明常量
  - const声明时必须赋值
  - 如果const声明一个引用类型存放在**堆内存**，声明的**引用地址**不能改变，但**堆内存中的内容**可以改变
- var：有变量提升，只是改变了所声明变量的作用域，可以重复声明覆盖

## 4.深拷贝

- 深浅拷贝是针对**引用类型**来说的。浅拷贝指**只复制了引用地址**，修改原值会影响所有复制值。深拷贝复制的对象之间不会互相影响。
- JS原生的实现深拷贝方法有
  - **JSON.stringfy/parse**，但对目标对象有要求，如果有**函数**、**symbol**值就会发生**引用丢失**；
  - Array的**concat/slice**，Object的**assign**和**展开运算符**：**首层深拷贝**
- 如果要实现真正的深拷贝，需使用**递归**
- 更特殊的，如果目标对象存在**循环引用**的情况，普通的递归会导致**爆栈**，要使用JS的Map类型创建一个哈希表，做循环检测判断





## 4. 杂项

- `===` 和 `==`
  - `===`：相同类型的前提下，相同的值或指向的地址；
  - `==`：类型相同，同 `===`；不同类型，由js**自动转换**后比较；

# 模块化开发

## webpack





## CJS 与 ESM

`CommonJS`和`ESModule`都是JavaScript的**模块化方案**

### CJS

ConmmonJS主要用于服务器端，**只能在NodeJS上运行**，使用 `require('MODULE')` 读取并加载模块。

### ESM

ESModule是最新的模块方案，使用 `import` `export` 管理模块。

### 区别

- CJS**同步**加载模块，在执行时才会对模块建立对象的**拷贝**；

- ESM**提前**加载模块并编译，建立**静态引用**，所以import只能放在文件**开头**，不能放在条件语句内（而且不允许在外部直接修改模块的值）；基于这个差异，ESM在打包阶段更好做`tree-shaking`。



# 浏览器

## 1. 跨域

跨域问题产生的根源在于**浏览器需要遵循同源策略**，在它的限制下，前后端只有在**协议**、**域名**、**端口**都相同时才能交换数据。所以在**前后端分离**的项目中我们必须要**规避**这种限制。

### Proxy

我们前端在开发过程中解决跨域最常用的方法是在项目中**配置代理服务器**，利用了**服务器间通讯没有跨域问题**的机制，**使用代理服务器转发请求**，过程概括为：

1. 在`vue.config.js` 中配置`devServer.proxy`，添加一个**代理标识**对象，例如 `"api":{}` 。填入要代理的路径target，设置`changeOrigin`字段为true。如果请求url中含有代理标识，就触发代理机制， 发送的请求路径会被拼接为 target + 代理标识 + url ；
2. 在Axios中配置请求前缀baseURL为代理标识，这样使用axios发送请求会自动经过代理服务器；
3. 如果不想让代理标识出现在请求url中，可以在`pathRewrite`字段中将代理标识替换成空字符串。

使用devServer的问题是他仅适用于开发环境，当Vue项目打包成静态文件时，他的代理也就失灵了。在生产环境中，可以在**使用nginx的反向代理**达到同样的效果。

### CORS

现在在生产环境中使用的主流解决方案是 **CORS 跨域资源共享** ，它是一种**基于HTTP协议头**的机制，通过服务器在响应头**声明白名单**，使得浏览器允许白名单内的源访问加载自己的资源。

通常在服务器配置响应头 `Access-Control-Allow-Origin: *`  即可解决大部分解决前后端分离项目的跨域问题。

>  [一文弄懂 CORS 跨域(前端+后端代码实例讲解) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/118381660) 



## 2. Storage Cookie

- 相同点： 都会在**浏览器端**保存，有大小限制、同源限制；
- cookie：
  - 大小：4k
  - 通信：cookie会默认附在请求头中，**自动**发送到服务器，服务器可修改cookie；
  - 寿命：**会话期**cookie默认在**浏览器关闭**后移除；**持久性**cookie在**指定过期时间**删除
- Web Storage：
  - 大小：5M
  - 通信：web storage 不会发送到服务器；
  - 寿命：`sessionStorage` 在浏览器关闭时清空；`localStorage` 数据会保留至**主动**通过js清空或用户**清除浏览器缓存**；
  - 作用域：`sessionStorage` 必须在**同一窗口**下使用；`localStorage` 在**同源策略**下都可共享；

## 3. DOM事件

`捕获`和`冒泡`两个阶段：

- 捕获从window开始依次传递到目标元素，冒泡从目标元素传递到window对象；
- 通常利用冒泡机制实现**事件托管**，提高程序性能；



# 计算机网络

## 1. 输入url到渲染

三类设备五个阶段

- 客户端（浏览器） - 网络 - 服务器端

- 阶段

  1. 构造和发起请求

     检查缓存（Http1.0使用`Expires`，1.1使用`Cache-Control`）

     1. 解析URL：输入域名后浏览器从URL中解析出 **协议、域名、路径**

     2. 组装Http request：**请求行/请求头/空行/请求体**

     3. 解析DNS：拿到域名后，浏览器依次从**浏览器缓存**、**hosts文件**、**路由器缓存**、**ISP缓存**中查找IP地址，如果都没有则进行**DNS递归查询**

        

  2. 网络传输

     1. 建立TCP连接，**三次握手**：

        ```
        客户端发送 SYN=1，							Seq=X
        服务端返回 SYN=1，	ACK=X+1，		Seq=Y
        客户端发送 				ACK=Y+1，		Seq=Z
        ...
        ```

     2. 建立成功后发送HTTP请求

        

  3. 服务端处理

     1. 解析请求，转发到服务处理程序

     2. 处理程序验证、查库，

     3. 通过TCP返回Http response：**状态行/响应头/空行/响应体**

        

  4. 同二，方向相反

     1. 浏览器接收响应，然后双方根据情况选择**保留重用**或者**关闭 TCP 连接**（**四次挥手**）

        ```
        主动方发送一次		FIN=1		ACK=+1		Seq=X
        被动方返回两次       		ACK=X+1		Seq=Y		// 可能存在未发送完毕的数据
        							FIN=1		ACK=X			Seq=Z
        主动方发送一次					  ACK=Z
        ```

        

  5. 浏览器处理

     1. 从response中解析html代码，通过语法分析生成AST，构建DOM树
     2. CSS属性计算，依据选择器和优先级，构建CSSOM树
     3. 将 DOM 与 CSSOM 合并成一个渲染树
     4. 排版：获取节点中用于排版的CSS属性，根据盒模型和格式化上下文计算元素产生的盒和位置
     5. 渲染：获取节点中用于渲染的CSS属性，调用GPU合成图层，并绘制到显示设备

## 2. get post 区别

GET 和 POST 只是 HTTP 协议中两种请求方式。GET常用于向服务器查询、获取数据，POST常用于发送修改请求。

从传输层协议上看，二者基本没有区别。通常来说，GET的查询参数会直接放在URL中，而POST放在请求体中，而且URL比起请求体长度受限，所以有POST更安全、可传输信息更大之说。

但要知道HTTP在网络上是明文传输的，只要在节点上抓包，请求体内容一样可见，POST并不一定安全。至于长度限制，我们完全可以把GET的查询参数放在请求体中，只要服务器支持即可。

综上，二者并无本质区别。

# VUE

## 1. vue2组件通信方式



## 2. 双向绑定



## 3. v-show v-if

- v-if在切换时会将条件块的事件监听器和子组件进行**销毁和重组**。如果初始条件为`false`，则什么也不做，直到条件为true时才会开始渲染。
- v-show只是**基于CSS**进行切换，不管初始条件如何，始终会渲染。

v-show的初始化开销更大，v-if的切换开销更大。

- 在需要频繁切换，或者切换部分DOM很复杂时，v-show更合适；
- 渲染后很少切换的，使用v-if更合适；

## 4. v-for中key的作用

`key`是给v-for中每个`vnode`指定的唯一id，在同级`vnode`diff过程中，可以通过`key`快速对比，来判断是否为相同节点，并且利用key的唯一性可以生成`map`来更快地获取相应节点。

# CSS

## BFC

**Block Formatting Context 块级格式化上下文** 

### 概念

BFC与IFC、FFC等概念同属于CSS**格式化上下文**的一种，实质是一种**布局环境**，它们规定了内部的box如何布局，从而形成了独立的渲染区域。

### 布局规则

- BFC内部的盒子从包含块的顶部，一个接着一个地放置**垂直排列**；
- BFC内部的盒子的**margin**紧贴包含块的**border**；
- 计算创建BFC的盒子高度时**会将浮动元素也计入其中**；

### 特性

通过为容器**创建BFC**可以使它成为**独立容器，与外界互不影响**：

- **包含内部浮动**，避免溢出导致浮动子元素令父元素高度坍塌；
- **排除外部浮动**，避免被覆盖；
- **避免外边距坍塌**，属于同一个BFC的相邻盒子垂直方向margin会重叠，将其放在不同的 BFC 容器中即可避免；

### 创建

创建BFC的方式有很多：

- 根元素
- 浮动元素（float不为none）
- 绝对定位元素（position为absolute或fixed）
- 表格元素
- 弹性元素、网格元素（display为flex/grid的直接子元素）
- `overflow` 不为visible的块元素

以上方法在某些情况下可能会产生**副作用**，如果要为一个容器专门创建BFC，建议使用的是 **`display: flow-root`** 属性，它可以创建无副作用的 BFC。

>  [块格式化上下文 - Web 开发者指南 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context) 
>
>  [视觉格式化模型 - CSS（层叠样式表） | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Visual_formatting_model) 
>
>  [Formatting context（FC） - 掘金 (juejin.cn)](https://juejin.cn/post/6974636270848835592) 
>
> block-level element =>  block-level box 块级元素生成块级盒子，如果**块级盒子**同时也是一个**块容器盒子 block container box **，则称其为**块盒子 block box **，