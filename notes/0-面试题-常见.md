# JS

## 1. 基本数据类型

- 7种值类型：Number、String，Boolean，Null、undefined，Symbol，BigInt；

- 1种引用类型：Object；

  js的变量存放于**堆**（对于有名对象， 会在栈中存一个**堆内地址的引用** （JS的栈与其他语言不同，属于抽象的执行上下文栈））

## 2. 闭包

常见说法：闭包是在某个作用域内定义的**函数和其词法环境的组合**，闭包让你可以在一个内层函数中访问到其外层函数的作用域。常使用于 **创建特权方法用于访问控制** 和 **回调函数** 中。

实际上，闭包其实是JavaScript内存使用机制产生的必然结果，它与**执行上下文**、**作用域与作用域对象**、**变量储存方式**、**垃圾回收机制**息息相关：

以chrome使用的V8引擎为例。如果我们在js中声明一个函数 `myFunc()`，myFunc标识符会在声明的同时存入当前的**作用域对象**中，这个标识符引用的是一个堆上的函数对象。而这个函数对象除了包含代码之外，还会产生一个内部属性 `[[scopes]]`，**scopes会反过来引用声明这个函数时所在的作用域对象的集合**，这个作用域对象就叫做 `myFunc()` 的**词法作用域**。由此可见，**凡是由我们主动声明的函数都会产生闭包**！（注意：这一切都发生在 `myFunc()` 执行之前）

当 `myFunc()` 执行开始时，JS的执行上下文栈会将 `myFunc()` 推到栈顶，同时产生一个新的作用域对象形成**作用域链**。当JS在当前作用域找不到变量时，就通过 `[[scopes]]` 去父作用域中寻找（这一点类似原型链），如果找到了，就会形成对**父作用域对象**的**引用**，当 `myFunc()` 执行结束出栈时，这个引用就会被解除。如果一个作用域对象不再被任何对象引用，就会被添加回收标记，在**垃圾回收器**（garbage collector）的下一次轮询中销毁。大部分函数的结果都是如此，它们产生的闭包转瞬即逝，不会被我们感知。

现在设想一种特殊情况：在全局中声明一个嵌套有子函数的函数，且子函数对父函数的属性**形成引用**。这时，如果我们将子函数作为父函数的返回值，这个返回值将作为全局变量保存起来，而**全局变量是不会被回收的**，那么意味着子函数的 `[[scopes]]` 保存的**父作用域对象也会一并保存下来**！即使父函数执行结束，它内部被引用的属性也不会销毁。这样一来，我们**能且只能**通过子函数随时访问这个父函数的变量，这个子函数即为**特权方法**，父函数的属性就是**私有属性**。

综上，闭包的优缺点也就呼之欲出：

- 优点： 保护函数内的变量安全 ，实现封装；在内存中维持一个变量，可以做缓存；
- 缺点： 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏；

>  [Javascript闭包：从理论到实现，[[Scopes\]]的每一根毛都看得清清楚楚](https://segmentfault.com/a/1190000015311755) 

## 4. this



## 事件循环

JS的执行栈在调用异步方法时会往**任务队列**中添加事件，栈中的代码执行完毕后就会**轮询**，循环读取队列中的事件。

浏览器环境中，JS有宏任务/微任务两类事件类型，微任务包含于宏任务中，遵循先宏后微的原则：

- 宏任务：script、setTimeout、setInterval、UI渲染
- 微任务：Promise、await、Nodejs的NextTick

Nodejs的事件循环基于自己设计的libuv，与浏览器完全不同。





## 4.深拷贝

- 深浅拷贝是针对**引用类型**来说的。浅拷贝指**只复制了引用地址**，修改原值会影响所有复制值。深拷贝复制的对象之间不会互相影响。
- JS原生的实现深拷贝方法有
  - **JSON.stringfy/parse**，但对目标对象有要求，如果有**函数**、**symbol**值就会发生**引用丢失**；
  - Array的**concat/slice**，Object的**assign**和**展开运算符**：**首层深拷贝**
- 如果要实现真正的深拷贝，需使用**递归**
- 更特殊的，如果目标对象存在**循环引用**的情况，普通的递归会导致**爆栈**，要使用JS的Map类型创建一个哈希表，做循环检测判断

## 5. 防抖节流

防抖和节流是两种**控制事件触发频率**的方法，都返回一个**存有私有变量的闭包**。

- 防抖是**事件导向**的，思路是**控制事件触发次数**：
  - **非立即执行防抖**：连续触发事件停止触发一段时间后，才执行处理函数；
  - **立即执行防抖**：触发事件后立即执行一次处理函数，停止触发一段时间后才能继续执行。
- 节流是**时间导向**的，思路是**稀释函数执行频率**：
  - **时间戳法**：在闭包内保存一个时间戳，事件触发后立即执行，下次触发的事件与时间戳的间隔大于delay才会执行；
  - **定时器法**：在闭包内保存定时器，每隔一段时间清空定时器并执行函数。



## 图片懒加载

懒加载可以加速首屏加载，减轻服务器数据；

实现：

1. `offsetTop`、`scrollTop`、`clientHeight`数值计算，使用节流监听滚动事件；
2. `IntersectionObserver`API可以监听元素与视窗的交叉状态，无需设置节流。但要考虑兼容性问题。

## 

# 模块化开发

## 1. webpack

webpack是实现前端工程化的重要工具，它可以把项目中分散的模块打包成**静态资源bundles**，实现方便的**自动化构建**。

- 工作流程
  - 从配置文件读取并合并**参数**；
  - 根据参数**初始化`Compiler`对象**，**加载`plugin`**；
  - 根据配置中的`entry`找出所有**入口文件**；
  - 从入口文件出发，针对每个模块，**链式调用`Loader`编译模块和它的依**赖；
  - 将编译后的模块**组装为`chunk`**，输出到文件；

- plugin与loader
  - plugin，插件，丰富了webpack功能和API。依赖webpack的事件流机制，构建过程中会广播每个环节对应的事件，plugin通过监听这些事件，通过webpack提供的API改变输出结果。
  - Loader本质是函数。因为webpack只识别JS，loader接收其他类型的资源并翻译成webpack能处理的模块。
  - plugin在module.plugins数组中配置；loader在module.rules数组中配置，其中包含test、loader、options。
- sourcemap
  - 打包后的代码不具有可读性，难以调试，通过sourcemap可以将打包后的代码映射回源代码，方便调试。需要在配置中手动打开这个功能。
- 用过的plugin
  - `HMR`：热替换，实时更新，不用刷新浏览器而将新变更的模块替换掉旧的模块；
  - `webpack-dashboard`：显示构建信息（webpack5不能用）；
  - `webpack-merge`：提取公共配置，减少重复代码；
  - `SMP`：分析打包时间，找出plugin和loader的耗时瓶颈； 



## 2. CJS 与 ESM

`CommonJS`和`ESModule`都是JavaScript的**模块化方案**

### CJS

ConmmonJS主要用于服务器端，**只能在NodeJS上运行**，使用 `require('MODULE')` 读取并加载模块。

### ESM

ESModule是ES6的模块方案，使用 `import` `export` 管理模块。

### 区别

- CJS**动态导入模块**，是**同步**的，动态在执行时才会对模块建立对象的**拷贝**；
- ESM**提前**加载模块并编译，**异步**建立**静态引用**，所以import只能放在文件**开头**，不能放在条件语句内（而且不允许在外部直接修改模块的值）；
- CJS的`dynamic`特性意味着在代码运行之前无法确定模块依赖，所以无法实现`tree-shaking`，ESM则可以。



# 浏览器

## 跨域

跨域问题产生的根源在于**浏览器需要遵循同源策略**，在它的限制下，前后端只有在**协议**、**域名**、**端口**都相同时才能交换数据。所以在**前后端分离**的项目中我们必须要**规避**这种限制。

### Proxy

我们前端在开发过程中解决跨域最常用的方法是在项目中**配置代理服务器**，利用了**服务器间通讯没有跨域问题**的机制，**使用代理服务器转发请求**，过程概括为：

1. 在`vue.config.js` 中配置`devServer.proxy`，添加一个**代理标识**对象，例如 `"api":{}` 。填入要代理的路径target，设置`changeOrigin`字段为true。如果请求url中含有代理标识，就触发代理机制， 发送的请求路径会被拼接为 target + 代理标识 + url ；
2. 在Axios中配置请求前缀baseURL为代理标识，这样使用axios发送请求会自动经过代理服务器；
3. 如果不想让代理标识出现在请求url中，可以在`pathRewrite`字段中将代理标识替换成空字符串。

使用devServer的问题是他仅适用于开发环境，当Vue项目打包成静态文件时，他的代理也就失灵了。在生产环境中，可以在**使用nginx的反向代理**达到同样的效果。

### CORS

现在在生产环境中使用的主流解决方案是 **CORS 跨域资源共享** ，它是一种**基于HTTP协议头**的机制，通过服务器在响应头**声明白名单**，使得浏览器允许白名单内的源访问加载自己的资源。

通常在服务器配置响应头 `Access-Control-Allow-Origin: *`  即可解决大部分解决前后端分离项目的跨域问题。

>  [一文弄懂 CORS 跨域(前端+后端代码实例讲解) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/118381660) 



## Storage Cookie

- 相同点： 都会在**浏览器端**保存，有大小限制、同源限制；
- cookie：
  - 大小：4k
  - 通信：cookie会默认附在请求头中，**自动**发送到服务器，服务器可修改cookie；
  - 寿命：**会话期**cookie默认在**浏览器关闭**后移除；**持久性**cookie在**指定过期时间**删除
- Web Storage：
  - 大小：5M
  - 通信：web storage 不会发送到服务器；
  - 寿命：`sessionStorage` 在浏览器关闭时清空；`localStorage` 数据会保留至**主动**通过js清空或用户**清除浏览器缓存**；
  - 作用域：`sessionStorage` 必须在**同一窗口**下使用；`localStorage` 在**同源策略**下都可共享；



## 浏览器缓存

在浏览器加载资源的时候，首先会根据请求头的`expires`和`cache-control`判断是否命中**强缓存策略**，判断是否向远程**服务器**请求资源还是去**本地**获取缓存资源。

### 强缓存

强缓存在时效时间内，不走服务端，只走本地缓存 

- Expires - http1.0

  用于表示资源的**过期时间**的请求头字段，这是一个**绝对时间**。当浏览器在下一次请求这个资源时会根据上次的`expires`字段是否使用缓存资源。

  它的问题是expires是**根据本地时间来判断的**，假设客户端和服务器时间不同，会导致**缓存命中误差**。

  

- Catch-Control - http1.1

  Catch-Control是相对时间，没有误差问题。

### 协商缓存

当浏览器没有命中强缓存时，就会向服务器验证协商缓存是否命中，如果命中则返回**304**状态码，否则返回新数据。

- 如何判断是否命中

  浏览器第一次发出请求时会带上字段`Last-Modified`或者`Etag`，



## DOM事件

`捕获`和`冒泡`两个阶段：

- 捕获从window开始依次传递到目标元素，冒泡从目标元素传递到window对象；
- 通常利用冒泡机制实现**事件托管**，提高程序性能；

## 重绘和回流

依据个人理解，其实叫做重绘和重排更好

- 回流对应浏览器渲染的排版（layout）阶段，排版会根据格式化上下文和盒模型确定盒子位置、大小，而回流就是页面元素几何尺寸变化时引起的重新排版，需要更新渲染树，十分消耗资源。
- 重绘对应（painting）阶段，渲染与元素位置无关的样式，销毁资源相对小。
- 重绘不一定发生回流，回流一定发生重绘。

从渲染角度优化性能：

- 多使用**局部布局**（BFC），尽可能小的影响重排范围；
- 避免频繁操作样式和过深的嵌套，尽量通过切换class的方式应对复杂变化；
- 对于复杂动画的元素使用**绝对定位**（fixed，absolute），使它**脱离文档流**；
- 通过`display: none`属性，隐藏元素后修改样式再显示，不会触发重绘回流；



## Http2.0

- 所有的数据以**二进制**形式传输
- 支持信道**多路复用**，一个TCP连接里可以发送多个请求，不再需要按着顺序来，减少等待TCP连接的时间
- **头信息压缩**，减少宽带使用
- 支持**服务器推送**功能（服务端可以主动给客户端发请求），提高了传输效率



# 计算机网络

## 1. 输入url到渲染

三类设备五个阶段

- 客户端（浏览器） - 网络 - 服务器端

- 阶段

  1. 构造和发起请求

     检查缓存（Http1.0使用`Expires`，1.1使用`Cache-Control`）

     1. 解析URL：输入域名后浏览器从URL中解析出 **协议、域名、路径**

     2. 组装Http request：**请求行/请求头/空行/请求体**

     3. 解析DNS：拿到域名后，浏览器依次从**浏览器缓存**、**hosts文件**、**路由器缓存**、**ISP缓存**中查找IP地址，如果都没有则进行**DNS递归查询**

        

  2. 网络传输

     1. 建立TCP连接，**三次握手**：

        ```
        客户端发送 SYN=1，							Seq=X
        服务端返回 SYN=1，	ACK=X+1，		Seq=Y
        客户端发送 				ACK=Y+1，		Seq=Z
        ...
        ```

     2. 建立成功后发送HTTP请求

        

  3. 服务端处理

     1. 解析请求，转发到服务处理程序

     2. 处理程序验证、查库，

     3. 通过TCP返回Http response：**状态行/响应头/空行/响应体**

        

  4. 同二，方向相反

     1. 浏览器接收响应，然后双方根据情况选择**保留重用**或者**关闭 TCP 连接**（**四次挥手**）

        ```
        主动方发送一次		FIN=1		ACK=+1		Seq=X
        被动方返回两次       		ACK=X+1		Seq=Y		// 可能存在未发送完毕的数据
        							FIN=1		ACK=X			Seq=Z
        主动方发送一次					  ACK=Z
        ```

        

  5. 浏览器处理

     1. 从response中解析html代码，通过语法分析生成AST，构建DOM树
     2. CSS属性计算，依据选择器和优先级，构建CSSOM树
     3. 将 DOM 与 CSSOM 合并成一个渲染树
     4. 排版：获取节点中用于排版的CSS属性，根据盒模型和格式化上下文计算元素产生的盒和位置
     5. 渲染：获取节点中用于渲染的CSS属性，调用GPU合成图层，并绘制到显示设备



## WebSocket

常用的http协议是**短链接**，每次请求之后都会关闭连接，下次请求需要重新打开，在需要频繁通讯的场景比较耗费资源。Websocket协议可以解决这个问题，它通过一次初始化就可以 

是一种在单个TCP连接上建立的**全双工通讯协议**。

与Http不同，它可以建立长连接，允许数据**同一时间**在**两个方向**上同时传输。

> 浏览器与服务器实时通讯的方案：
>
> 1. AJAX



# VUE

## 1. vue2组件通信方式

- 父子：props、$emit
- 获取实例：ref
- 兄弟间：eventbus
- 祖先传递数据给子孙： `$attrs`和 `$listeners` 
- VueX

## 2. 双向绑定

v-bind+v-on语法糖

## 3. 响应式原理

 Object.defineProperty() / Proxy 做数据劫持

通过`Object.defineProperty`为对象`obj`添加属性，可以设置对象属性的`getter`和`setter`函数。之后我们每次通过 `.` 语法获取属性都会执行这里的`getter`函数，在这个函数中我们会把调用此属性的依赖收集到一个**集合**中 ；而在我们给属性赋值(修改属性)时，会触发这里定义的`setter`函数，在次函数中会去通知集合中的**依赖更新**，做到**数据变更驱动视图变更**。

## 3. v-show v-if

- v-if在切换时会将条件块的事件监听器和子组件进行**销毁和重组**。如果初始条件为`false`，则什么也不做，直到条件为true时才会开始渲染。
- v-show只是**基于CSS**进行切换，不管初始条件如何，始终会渲染。

v-show的初始化开销更大，v-if的切换开销更大。

- 在需要频繁切换，或者切换部分DOM很复杂时，v-show更合适；
- 渲染后很少切换的，使用v-if更合适；

## 4. v-for中key的作用

`key`是给v-for中每个`vnode`指定的唯一id，在同级`vnode`diff过程中，可以通过`key`快速对比，来判断是否为相同节点，并且利用key的唯一性可以生成`map`来更快地获取相应节点。

# CSS

## BFC

**Block Formatting Context 块级格式化上下文** 

### 概念

BFC与IFC、FFC等概念同属于CSS**格式化上下文**的一种，实质是一种**布局环境**，它们规定了内部的box如何布局，从而形成了独立的渲染区域。

### 布局规则

- BFC内部的盒子从包含块的顶部，一个接着一个地放置**垂直排列**；
- BFC内部的盒子的**margin**紧贴包含块的**border**；
- 计算创建BFC的盒子高度时**会将浮动元素也计入其中**；

### 特性

通过为容器**创建BFC**可以使它成为**独立容器，与外界互不影响**：

- **包含内部浮动**，避免溢出导致浮动子元素令父元素高度坍塌；
- **排除外部浮动**，避免被覆盖；
- **避免外边距坍塌**，属于同一个BFC的相邻盒子垂直方向margin会重叠，将其放在不同的 BFC 容器中即可避免；

### 创建

创建BFC的方式有很多：

- 根元素
- 浮动元素（float不为none）
- 绝对定位元素（position为absolute或fixed）
- 表格元素
- 弹性元素、网格元素（display为flex/grid的直接子元素）
- `overflow` 不为visible的块元素

以上方法在某些情况下可能会产生**副作用**，如果要为一个容器专门创建BFC，建议使用的是 **`display: flow-root`** 属性，它可以创建无副作用的 BFC。

>  [块格式化上下文 - Web 开发者指南 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context) 
>
>  [视觉格式化模型 - CSS（层叠样式表） | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Visual_formatting_model) 
>
>  [Formatting context（FC） - 掘金 (juejin.cn)](https://juejin.cn/post/6974636270848835592) 
>
> block-level element =>  block-level box 块级元素生成块级盒子，如果**块级盒子**同时也是一个**块容器盒子 block container box **，则称其为**块盒子 block box **，





# 优化

## 首屏优化