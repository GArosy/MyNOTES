# JS数据结构与算法—哈希表

「哈希」（Hash）也称为「散列」，它描述一个「输入任意长度的数据 > 散列算法 > 输出固定长度的摘要」的过程，这个过程又被称为**哈希化**，这个散列算法即**哈希函数**。

## 哈希表

「哈希表」（Hash table）也称为「散列表」，是根据**键值**直接进行访问的**数据结构**。哈希表的基本结构类似数组， 但是它神奇的地方在于对下标值的一种变换， 这种变换我们可以称之为哈希函数，通过哈希函数可以获取到`HashCode` 。

- 哈希化: 将大数字转化成数组范围内下标的过程， 我们就称之为哈希化；
- 哈希函数: 通常我们会将单词转成大数字， 大数字在进行哈希化的代码实现放在一个函数中， 这个函数我们成为哈希函数；
- 哈希表: 最终将数据插入到的这个数组， 我们就称之为是一个哈希表；

优势：

- 它可以提供非常快速的插入-删除-查找操作；
- 无论多少数据， 插入和删除值需要接近常量的时间: 即**O(1)**的时间级. 实际上， 只需要几个机器指令即可；
- 哈希表的速度比树还要快， 基本可以瞬间查找到想要的元素；
- 哈希表相对于树来说编码要容易很多；

缺点：

- 哈希表中的数据是没有顺序的， 所以不能以一种固定的方式(比如从小到大)来遍历其中的元素；
- 通常情况下， 哈希表中的key是不允许重复的， 不能放置相同的key， 用于保存不同的元素；

## 哈希算法

一个好的哈希算法应满足下列要求：

- 一致性——同样的输入必然产生同样的输出；
- 安全性——不同的输入大概率产生不同的输出，且难以从输出反推输入；
- 均匀性——均匀地散列所有的输出值；

1. 除法散列法

   散列长度 m, 对于一个小于 m 的数 p 取模，所得结果为散列地址。对 p 的选择很重要，一般取素数或 m 

   ```js
   // f(k) = k % p （p<=m）
   index = key % 7
   ```

2. 平方散列法

   先通过求关键字的平方值扩大相近数的差别，然后根据表长度取中间的几位数作为散列函数值。又因为一个乘积的中间几位数和乘数的每一位都相关，所以由此产生的散列地址较为均匀。 

   ```js
   // f(k) = ((k * k) >> X) << Y
   // 对于常见的32位整数而言，也就是 f(k) = (k * k) >> 28
   index = (key * key) >> 28
   ```

3. 斐波那契（Fibonacci）散列法

   和平方散列法类似，此种方法使用斐波那契数列的值作为乘数而不是自己。

   1. 对于 16 位整数而言，这个乘数是 40503。
   2. 对于 32 位整数而言，这个乘数是 2654435769。
   3. 对于 64 位整数而言，这个乘数是 11400714819323198485。

   > 为什么使用斐波那契数列后散列更均匀，涉及到相关数学问题，此处不做更多解释

   ```js
   index = (key* 2654435769) >> 28
   ```

## 哈希碰撞

哈希算法是把一个无限的输入集合映射到一个有限的输出集合的过程，必然会产生碰撞。 解决冲突常见有两种方案：**链寻址法**（拉链法）和**开放寻址法**。 

### 链寻址法

如下图所示，我们将每一个数字都对 10 进行取余操作，则余数的范围 0~9 作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的数组或链表。

![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c374961f1027426d9cb1a589607ddcf4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。

总结：链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一条链条，这条链条常使用的数据结构为数组或链表，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。

### 开放寻址法

开放地址法的主要工作方式是寻找空白的单元格来放置冲突的数据项。

![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85177f5c6c94ad796d68f382cdb3dae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

根据探测空白单元格位置方式的不同，可分为三种方法：

- 线性探测
- 二次探测
- 再哈希法

#### 线性探测

- 当插入 13 时：

经过哈希化（对 10 取余）之后得到的下标值 index=3，但是该位置已经放置了数据 33。而线性探测就是从 index 位置+1 开始向后一个一个来查找合适的位置来放置 13，所谓合适的位置指的是空的位置，如上图中 index=4 的位置就是合适的位置。

- 当查询 13 时：
  - 首先 13 经过哈希化得到 index=3，如果 index=3 的位置存放的数据与需要查询的数据 13 相同，就直接返回； 不相同时，则线性查找，从 index+1 位置开始一个一个位置地查找数据 13。
  - 查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入 13 时不会跳过空位置去插入其他位置。
- 当删除 13 时：
  - 删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，不能将该位置下标的内容设置为 null，否则会影响到之后其他的查询操作，因为一遇到为 null 的位置就会停止查找。
  - 通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为-1），这样在查找时遇到-1 就知道要继续查找。

线性探测存在的问题：

- 线性探测存在一个比较严重的问题，就是聚集。
- 如哈希表中还没插入任何元素时，插入 23、24、25、26、27，这就意味着下标值为 3、4、5、6、7 的位置都放置了数据，这种一连串填充单元就称为聚集。
- 聚集会影响哈希表的性能，无论是插入/查询/删除都会影响。
- 比如插入 13 时就会发现，连续的单元 3~7 都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。

 ![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cefcb3cb0f7e4666a96f483477e9e95b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp) 

#### 二次探测

上文所说的线性探测存在的问题：

- 如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离；

  二次探测是在线性探测的基础上进行了优化：

- 线性探测：我们可以看成是步长为 1 的探测，比如从下表值 x 开始，那么线性探测就是按照下标值：x+1、x+2、x+3 等依次探测；

- 二次探测：对步长进行了优化，比如从下标值 x 开始探测：x+1^2^、x+2^2^、x+3^3^ 。这样一次性探测比较长的距离，避免了数据聚集带来的影响。

- 二次探测存在的问题：

  当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成步长不一的一种聚集（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。

#### 再哈希法

在开放地址法中寻找空白单元格的最好的解决方式为再哈希化。

- 二次探测的步长是固定的：1，4，9，16 依次类推。
- 现在需要一种方法：产生一种依赖关键字(数据)的探测序列，而不是每个关键字探测步长都一样。
- 这样，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。
- 再哈希法的做法为：把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长。

第二次哈希化需要满足以下两点：

- 和第一个哈希函数不同，不然哈希化后的结果仍是原来位置；
- 不能输出为 0，否则每次探测都是原地踏步的死循环；

优秀的哈希函数：

- stepSize = constant - （key % constant）；
- 其中 constant 是质数，且小于数组的容量；
- 例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为 0；

## 哈希化的效率

哈希表中执行插入和搜索操作效率是非常高的。

- 如果没有发生冲突，那么效率就会更高；
- 如果发生冲突，存取时间就依赖后来的探测长度；
- 平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度会越来越长。

### 装填因子

- 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值；
- 装填因子 = 总数据项 / 哈希表长度；
- 开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素；
- 链地址法的装填因子可以大于 1，因为只要愿意，拉链法可以无限延伸下去；

### 不同探测方式性能的比较

- ###### 线性探测

  可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。

  ![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bab1e901a4a740ae873b77a8d0952516~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

- 二次探测和再哈希化的性能

  二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。

  ![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f97dfb2b1fb043fbada629f4253c984f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

- 链地址法的性能

  可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如 Java 中的 HashMap 中使用的就是链地址法。

  ![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c80165682804634afe18c676bb8198b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)


